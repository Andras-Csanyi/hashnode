---
title: "Dev Diary #1"
datePublished: Sat Nov 04 2023 15:42:37 GMT+0000 (Coordinated Universal Time)
cuid: clok7qvw5000808l7e7v25l9e
slug: dev-diary-1
tags: spring, java, dev-diaries, dev-diary

---

A few weeks ago I decided to drop C# and focus on java.

%[https://x.com/csanyi_andras/status/1712870405872968150?s=20] 

In the last few weeks, I rewrote the [Encyclopedia Galactica](https://github.com/EncyclopediaGalactica/EncyclopediaGalactica) project to java and I'll do a walkthrough now.

The whole project was built in Spring. I'm trying to apply some of the Domain Driven Design principles I'm aware of. The fact is that I know little about it and I know that clean code and clean architecture come with it. I apply these principles slowly at the pace I see fit.

## Architecture

The application is a 3-tier architecture. The database is planned to be Postgres, the business logic layer is Spring and the UI is HTML and it seems HTMX. If I take a look at the whole domain I want to be covered by this app the architecture will be event stream with microservices and all the nine-yard. For more details see the [project's page](https://encyclopediagalactica.github.io/EncyclopediaGalactica/encyclopedia-galactica-doc/start-page.html).

Since I develop this beast alone I have to keep it as simple as possible.

## Codebase

At this level I try to apply clean code and clean architecture things. As I mentioned previously I'm not experienced in this yet. But, if I were I would not apply them blindly. Whatever I do it has to go through my understanding.

We have 4 modules. The `common` is the cross-cutting concerns. The `document` and `iam` modules are the business domains, and the `ui` is the user interface.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1699111299184/bc7db54f-2b06-42a2-87ac-42304b484944.png align="center")

The `application` directory contains the business functionalities of a single module. There are `command`s and `query`s, but highly probable that I'm going to rename these to `scenario`. The reason is that I've got used to [BDD](https://en.wikipedia.org/wiki/Behavior-driven_development) language and there, everything is a scenario. My brain works better when it comes to scenarios and there is no brain froze when a command includes a query or vice versa. A scenario is a forgiving definition from this point of view.

When it comes to `contract`s I don't use a single DTO for input and output. I rather separate them. Why? Because... why not? I feel that this level of separation is good.

`entities` are the domain objects. These are persisted in the database and all the domain related operation happens to them.

`infra` includes Graphql and Rest endpoints related things, the mappers and the repositories. The infra stuff for Graphql means the `controllers` including the `@QueryMapping` and `@SchemaMapping` bindings to the application logic.

`mappers` directory includes the mappers implemented by [MapStruct](https://mapstruct.org/). Even though I like to write the mappers by hand and test the hell out of them I found MapStruct to be a good tool.

`repository` is where I leverage on Spring's Data JPA magic. These are just interfaces without any code written by me. There will be a point where I have to write repository-level logic and those files will be placed here.

`validation` contains the validation for the business scenarios. I create one or multiple validators for each business scenario. I use [Hibernate Bean Validator](https://hibernate.org/validator/) for this.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1699111517354/7ab22afb-bc51-4b93-9127-0581776b4f3a.png align="center")

## Devops

The project is built by maven.

The CI build is running on Github.